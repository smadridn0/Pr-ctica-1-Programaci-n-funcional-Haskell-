-- | miFilter :: (a -> Bool) -> [a] -> [a]
-- | Propósito: conservar solo los elementos que cumplen el requerimiento.
-- | Entradas: p (a -> Bool), xs [a]
-- | Salida: sublista de xs con los x tales que p x == True
miFilter :: (a -> Bool) -> [a] -> [a]
miFilter _ []     = []
miFilter p (x:xs) = if p x then x : miFilter p xs else miFilter p xs

-- | remData :: (Ord a) => [a] -> a -> a -> [a]
-- | Propósito: mantener elementos en el intervalo [lower, upper].
-- | Entradas: xs [a], lower a, upper a
-- | Salida: sublista con lower <= x <= upper
remData :: (Ord a) => [a] -> a -> a -> [a]
remData xs lower upper = miFilter (\x -> x >= lower && x <= upper) xs

-- | insertDesc :: Float -> [Float] -> [Float]
-- | Propósito: insertar un número en una lista ya ordenada DESC.
-- | Entradas: x :: Float, ys :: [Float] (ordenada desc)
-- | Salida: lista resultante, también ordenada desc, usando solo (:)
insertDesc :: Float -> [Float] -> [Float]
insertDesc x [] = [x]
insertDesc x (y:ys)
  | x >= y    = x : y : ys
  | otherwise = y : insertDesc x ys

-- | orderDesc :: [Float] -> [Float]
-- | Propósito: ordenar números en orden descendente.
-- | Entrada: lista de Float
-- | Salida: la misma lista ordenada de mayor a menor
orderDesc :: [Float] -> [Float]
orderDesc []     = []
orderDesc (p:xs) = insertDesc p (orderDesc xs)

-- | main :: IO ()
-- | Propósito: ejemplos de uso
main :: IO ()
main = do
  print (remData [1,9,3,7,2,6,4,8,5,10] 2 6)
  print (orderDesc [3.8,1.2,5.1,2.7,5.4])

