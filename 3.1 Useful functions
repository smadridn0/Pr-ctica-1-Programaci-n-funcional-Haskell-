-- | miFilter :: (Float -> Bool) -> [Float] -> [Float]
-- | Propósito: Conservar solo los elementos que cumplen los requerimientos establecidos desde la función.
-- | Entradas: p (Float -> Bool), xs [Float]
-- | Salida: Una sublista de xs con los x tales que haya p x == True
miFilter :: (Float -> Bool) -> [Float] -> [Float]
miFilter _ []     = []
miFilter p (x:xs) = if p x then x : miFilter p xs else miFilter p xs

-- | remData :: [Float] -> Float -> Float -> [Float]
-- | Propósito: Mantener elementos en el intervalo [lower, upper].
-- | Entradas: xs [Float], lower Float, upper Float
-- | Salida: Una sublista con lower <= x <= upper
remData :: [Float] -> Float -> Float -> [Float]
remData xs lower upper = miFilter (\x -> x >= lower && x <= upper) xs

-- | insertDesc :: Float -> [Float] -> [Float]
-- | Propósito: Insertar un número en una lista ya ordenada "DESCENDENTEMENTE" (DESC).
-- | Entradas: x :: Float, ys :: [Float] (ordenada descendentemente)
-- | Salida: lista resultante, también ordenada descendentemente
insertDesc :: Float -> [Float] -> [Float]
insertDesc x [] = [x]
insertDesc x (y:ys)
  | x >= y    = x : y : ys
  | otherwise = y : insertDesc x ys

-- | orderDesc :: [Float] -> [Float]
-- | Propósito: Ordenar números en orden descendente.
-- | Entrada: Lista de Floats
-- | Salida: la misma lista dada, pero ordenada de mayor a menor.
orderDesc :: [Float] -> [Float]
orderDesc []     = []
orderDesc (p:xs) = insertDesc p (orderDesc xs)

-- | main :: IO ()
-- | Propósito: Establecer los ejemplos de uso.
main :: IO ()
main = do
  print (remData [1,9,3,7,2,6,4,8,5,10] 2 6)
  print (orderDesc [3.8,1.2,5.1,2.7,5.4])
